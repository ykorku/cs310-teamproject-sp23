package edu.jsu.mcis.cs310.tas_sp23;

import java.time.*;
import java.time.temporal.ChronoUnit;
import java.time.format.DateTimeFormatter;
import java.util.TimeZone;

/**
 * <p> This class contains information about a single employee punch. </p>
 * @author Landon Barrett
 */
public class Punch {

    private int id;
    
    /**
     * <p> The id is a number automatically generated by the database to
     * identify a punch. It is unique for every punch. </p>
     */
    private final int terminalid;
    
    /**
     * <p> The badge object is a unique id for an employee and a description. </p>
     */
    private final Badge badge;
    
    /**
     * <p> The punchtype is an enumerated data type that describes the type of 
     * punch. It can be a 'CLOCK-IN', 'CLOCK-OUT', or a 'TIME-OUT.' </p>
     */
    private final EventType punchtype;
    
    /**
     * <p> The originalTimeStamp is the date and time that the punch was made. </p>
     */
    private LocalDateTime originalTimeStamp;
    
    /**
     * <p> The adjustedTimeStamp is a rounded time to the shift start and shift
     * end times designated by an employee's shift.
     */
    private LocalDateTime adjustedTimeStamp;
    
    /**
     * <p> The PunchAdjustmentType is an enumerated data type that describes
     * the type of adjustment performed on the punch's originalTimeStamp </p>
     */
    private PunchAdjustmentType adjustmentType = PunchAdjustmentType.NONE;
    
    /**
     * <p> This method is the constructor for existing punches. </p>
     * @param terminalid
     * @param badge
     * @param punchtype 
     */
    public Punch(int terminalid, Badge badge, EventType punchtype) {
        
        LocalDateTime systemTime = LocalDateTime.now();
        this.terminalid = terminalid;
        this.badge = badge;
        this.punchtype = punchtype;
        this.originalTimeStamp = systemTime;
        
    }
    
    /**
     * <p> This method is the constructor for new punches. </p>
     * @param id
     * @param terminalid
     * @param badge
     * @param originalTimeStamp
     * @param punchtype 
     */
    public Punch(int id, int terminalid, Badge badge,
            LocalDateTime originalTimeStamp, EventType punchtype) {
        
        this.id = id;
        this.terminalid = terminalid;
        this.badge = badge;
        this.originalTimeStamp = originalTimeStamp;
        this.punchtype = punchtype;
    }
    
    /**
     * <p> This method returns the punch id. </p>
     * @return The punch id.
     */
    public int getId() {
        return id;
    }
    
    /**
     * <p> This method returns the punch terminalid. </p>
     * @return The terminalid.
     */
    public int getTerminalid() {
        return terminalid;
    }
    
    /**
     * <p> This method returns the punch badge object. </p>
     * @return The punch badge object.
     */
    public Badge getBadge() {
        return badge;
    }
    
    /**
     * <p> This method returns the punchtype. </p>
     * @return The punchtype.
     */
    public EventType getPunchtype() {
        return punchtype;
    }
    
    /**
     * <p> This method returns the punch's original time stamp. </p>
     * @return The originalTimeStamp
     */
    public LocalDateTime getOriginaltimestamp() {
        return originalTimeStamp;
    }
    
    /**
     * <p> This method returns the punch's timestamp rounded to their shift
     * schedule. </p>
     * @return The punch's rounded time stamp.
     */
    public LocalDateTime getAdjustedtimestamp() {
        return adjustedTimeStamp;
    }
    
    /**
     * <p> This method returns the type of adjustment performed on the punch's
     * original time stamp. </p>
     * @return The punch's adjustment type.
     */
    public PunchAdjustmentType getAdjustmentType() {
        return adjustmentType;
    }
    
    /**
     * <p> This method is a helper method for the {@link #adjust adjust()}
     * method. computes the duration between the employee's start and end time. </p> 
     * @param start
     * @param time
     * @param round
     * @return The duration between the employee's start and end time in
     * minutes.
     */
    private long adjust_helper(LocalTime start, LocalTime time, int round) {
        //adjustmentType = adjustmentType.INTERVAL_ROUND;
        return ((Math.floorDiv((Duration.between(start, time)
                .toMinutes()), round))+1)*round;
    }
    
    /**
     * <p> This method is a helper method for the 
     * {@link #over_schedule over_schedule()} method. It determines if the
     * employee's start or end time needs to be rounded to their schedule
     * start or end time. It applies the round and returns the adjusted time in
     * minutes. </p>
     * @param round
     * @return The adjusted time according to the employee's schedule.
     */
    private LocalTime over_schedule(int round) {
        LocalTime original = originalTimeStamp.toLocalTime();
        double mins = (original.getHour() * 60) + original.getMinute();
        double rnd = round;
        int before = (int)((Math.floor(mins/rnd))*rnd);
        int after = (int)((Math.ceil(mins/rnd)) * rnd);
        LocalTime time = original;
        
        if ((Math.abs(before - mins)) == (Math.abs(after - mins))) {
            time = LocalTime.of(((int)(mins/60)), ((int)(mins%60)));
            adjustmentType = adjustmentType.NONE;
        } else if ((Math.abs(before - mins)) > (Math.abs(after - mins))) {
            time = LocalTime.of((after/60),(after%60));
            adjustmentType = adjustmentType.INTERVAL_ROUND;
        } else if ((Math.abs(before - mins)) < (Math.abs(after - mins))) {
            time = LocalTime.of((before/60),(before%60));
            adjustmentType = adjustmentType.INTERVAL_ROUND;
        }

        return time;
    }
    
    /**
     * <p> This method is a a helper method for the {@
     * @param original
     * @return 
     */
    private LocalDateTime round_time(LocalDateTime original) {
        
        LocalDateTime temp = original;
        int sec = original.toLocalTime().getSecond();
        TimeZone tz = TimeZone.getDefault();
        if(sec >= 30) {
            temp = original.plusMinutes(1);
        }
        
        return temp;
        
    }
    
    private LocalTime adjustment_helper(LocalTime original) {
        LocalTime ariginal = original;
        LocalTime adjusted;
        
        int hour = original.getHour();
        int mins = original.getMinute();
        
        if (((mins%15)>7) && ((mins/15)>=3)) {
            hour = hour + 1;
            mins = 0;
        } else if (((mins%15)>7) && ((mins/15)<3)) {
            mins = (((mins/15)+1)*15);
        } else if ((mins%15)<=7) {
            mins = ((mins/15)*15);
        }
        adjusted = LocalTime.of(hour, mins);
        return adjusted;
    }

    public void adjust(Shift sh) {
        DayOfWeek workDay = DayOfWeek.from(originalTimeStamp.toLocalDate());
        DailySchedule s = sh.getDailySchedule(workDay);

        LocalDateTime rndDateTime = round_time(getOriginaltimestamp());

        LocalTime original_time = rndDateTime.toLocalTime()
                .truncatedTo(ChronoUnit.MINUTES);
        LocalDate original_date = rndDateTime.toLocalDate();

        String punch_type = getPunchtype().toString();
        // Adjusted shift start times
        LocalTime startRound = s.getShiftstart()
                .minus(Duration.ofMinutes((long)s.getRoundinterval()));
        LocalTime startGrace = s.getShiftstart()
                .plus(Duration.ofMinutes((long)s.getGraceperiod()));
        LocalTime startDock = s.getShiftstart()
                .plus(Duration.ofMinutes((long)s.getDockpenalty()));
        String day = getOriginaltimestamp().getDayOfWeek().toString().toLowerCase();

        // Adjusted shift stop times
        LocalTime stopRound = s.getShiftstop()
                .plus(Duration.ofMinutes((long)s.getRoundinterval()));
        LocalTime stopGrace = s.getShiftstop()
                .minus(Duration.ofMinutes((long)s.getGraceperiod()));
        LocalTime stopDock = s.getShiftstop()
                .minus(Duration.ofMinutes((long)s.getDockpenalty()));

        // Start and stop times for lunch
        LocalTime lunchStart = s.getLunchstart();
        LocalTime lunchStop = s.getLunchstop();
        // Weekday time adjustment
        if (!(workDay.equals(DayOfWeek.SATURDAY) || workDay.equals(DayOfWeek.SUNDAY))) {
            switch(punch_type) {
                case "CLOCK IN":
                    // Adjust lunch punch in to end of lunch
                    if (original_time.isAfter(lunchStart) && original_time.isBefore(lunchStop)) {
                        adjustedTimeStamp = LocalDateTime.
                                of(original_date, lunchStop);
                        adjustmentType = adjustmentType.LUNCH_STOP;
                    // Punch between 15 min before and 5 min after shift start
                    } else if (original_time.isAfter(startRound) && original_time.isBefore(startGrace)) {
                        adjustedTimeStamp = LocalDateTime
                                .of(original_date, s.getShiftstart());
                        adjustmentType = adjustmentType.SHIFT_START;
                    // Punch more than 15 mins before shift start
                    } else if (original_time.isBefore(startRound)) {
                        adjustedTimeStamp = LocalDateTime.of(original_date,
                                over_schedule(s.getRoundinterval()));
                    } else if (original_time.isAfter(startGrace) && original_time.equals(startDock)) {
                        adjustedTimeStamp = LocalDateTime.of(original_date, startDock);
                        adjustmentType = adjustmentType.SHIFT_DOCK;
                    } else {
                        adjustedTimeStamp = LocalDateTime
                                .of(original_date, adjustment_helper(original_time));
                    }
                    break;
                case "CLOCK OUT":
                    // Adjust lunch punch out to beginning of lunch
                    if (original_time.isAfter(lunchStart) && original_time.isBefore(lunchStop)) {
                        adjustedTimeStamp = LocalDateTime.of(original_date, lunchStart);
                        adjustmentType = adjustmentType.LUNCH_START;
                    // Punch between 15 min after and 5 min before shift ends
                    } else if (original_time.isAfter(stopGrace) && original_time.isBefore(stopRound)) {
                        adjustedTimeStamp = LocalDateTime
                                .of(original_date, s.getShiftstop());
                        adjustmentType = adjustmentType.SHIFT_STOP;
                    // Punch more than 15 mins after shift end
                    } else if (original_time.isAfter(stopRound)) {
                        adjustedTimeStamp = LocalDateTime.of(original_date,
                                over_schedule(s.getRoundinterval()));
                    } else if (original_time.isBefore(stopGrace)) {
                        adjustedTimeStamp = LocalDateTime.of(original_date, stopDock);
                        if (adjustedTimeStamp.isAfter(rndDateTime)) {
                            adjustmentType = adjustmentType.INTERVAL_ROUND;
                        } else if (adjustedTimeStamp.equals(rndDateTime) || adjustedTimeStamp.isBefore(rndDateTime)) {
                            adjustmentType = adjustmentType.SHIFT_DOCK;
                        }
                    } else {
                        adjustedTimeStamp = LocalDateTime
                                .of(original_date, adjustment_helper(original_time));
                    }
                    break;
                case "TIME OUT":
                    System.out.println("TIME OUT");
                    break;
                default:
                    System.out.println("Default");
                    break;
            }
        // Weekend time adjustment
        } else {
            switch(punch_type) {
                case "CLOCK IN":
                    adjustedTimeStamp = LocalDateTime.of(original_date,
                            over_schedule(s.getRoundinterval()));
                    break;
                case "CLOCK OUT":
                    adjustedTimeStamp = LocalDateTime.of(original_date,
                            over_schedule(s.getRoundinterval()));
                    break;
                case "TIME OUT":
                    System.out.println("TIME OUT");
                    break;
                default:
                    System.out.println("Default");
                    break;
        }
    }
}
    
    /**
     * <p> This method builds a description of the employee's punch with the
     * original time stamps. </p>
     * @return A description of the employee's punch with
     * the original time stamp. 
     */
    public String printOriginal() {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/dd/yyyy");
        String dateText = originalTimeStamp.format(formatter);

        formatter = DateTimeFormatter.ofPattern("HH:mm:ss");
        String timeText = originalTimeStamp.format(formatter);

        String dayOfWeek = originalTimeStamp.getDayOfWeek().toString()
                .substring(0, 3).toUpperCase();
        
        StringBuilder s = new StringBuilder();
        s.append("#").append(badge.getId()).append(" ");
        s.append(punchtype).append(": ").append(dayOfWeek).append(" ")
                .append(dateText).append(" ").append(timeText);
        
        return s.toString();

    }
    
    /**
     * <p> This method builds a description of the employee's punch with the
     * adjusted time stamps rounded to the employee's schedule. </p>
     * @return A description of the employee's punch with the adjusted time 
     * stamps.
     */
    public String printAdjusted() {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/dd/yyyy");
        String dateText = originalTimeStamp.format(formatter);
        
        formatter = DateTimeFormatter.ofPattern("HH:mm:ss");
        String timeText = adjustedTimeStamp.format(formatter);
        
        String dayOfWeek = originalTimeStamp.getDayOfWeek().toString()
                .substring(0, 3).toUpperCase();
        
        StringBuilder s = new StringBuilder();
        s.append("#").append(badge.getId()).append(" ")
                .append(punchtype).append(": ").append(dayOfWeek)
                .append(" ").append(dateText).append(" ")
                .append(timeText).append(" (").append(adjustmentType)
                .append(")");
        
        return s.toString();
    }
}
